(import* io)
(import* str)
; SPosition (Int,Int)
(def SPosition ^2)
(def SFail (\msg pos (\on_fail on_succ (on_fail msg pos))))
(def SSucc (\a (\on_fail on_succ (on_succ a))))
(def <-SMF (\x (x SFail)))
(def ,<-SMF (\x (. (<-SMF x) feed)))

(let showSPosition (showPair showInt showInt))
(let showPositionedChar (showPair showCharL showSPosition))
(let showListPositionedChar (showList showPositionedChar))

(def STAtom (\a f1 f2 f3 f4 f5 f6 f7 (f1 a)))
(def STInt (\a f1 f2 f3 f4 f5 f6 f7 (f2 a)))
(def STDouble (\a f1 f2 f3 f4 f5 f6 f7 (f3 a)))
(def STLeftPar (\f1 f2 f3 f4 f5 f6 f7 f4))
(def STRightPar (\f1 f2 f3 f4 f5 f6 f7 f5))
(def STLambda (\f1 f2 f3 f4 f5 f6 f7 f6))
(def STStr (\a f1 f2 f3 f4 f5 f6 f7 (f7 a)))
(def showSToken (\t (t
	(\a (. (showString "STAtom ") (showStringL a)))
	(\a (. (showString "STInt ") (showInt a)))
	(\a (. (showString "STDouble ") (showFloat a)))
	(showString "STLeftPar")
	(showString "STRightPar")
	(showString "STLambda")
	(\a (. (showString "STStr ") (showStringL a) ))
)))
(let showPositionedSTToken (showPair showSToken showSPosition))
(let showListPositionedSTToken (showList showPositionedSTToken))
(def caseSTAtom     (\s e c (s     e (K c) (K c) c c c (K c))))
(def caseSTInt      (\s e c (s (K c)     e (K c) c c c (K c))))
(def caseSTDouble   (\s e c (s (K c) (K c)     e c c c (K c))))
(def caseSTLeftPar  (\s e c (s (K c) (K c) (K c) e c c (K c))))
(def caseSTRightPar (\s e c (s (K c) (K c) (K c) c e c (K c))))
(def caseSTLambda   (\s e c (s (K c) (K c) (K c) c c e (K c))))
(def caseSTStr      (\s e c (s (K c) (K c) (K c) c c c     e)))

(def STTNode (\a f1 f2 (f1 a)))
(def STTList (\a f1 f2 (f2 a)))
(def showSTokenTree (\t (let
	(show' (recur (\self (\t indent pos (t
		(\token (. (iterateN indent (cons ' ')) (. (showSToken token) (. (showString ";") (. (showSPosition pos) (showString "\n"))))))
		(\trees (. (iterateN indent (cons ' ')) (. (showString "STTree;") (. (showSPosition pos) (. (showString "\n") (concatShow (map (\xp (self (fst xp) (+ indent 4) (snd xp))) trees)))))))
	)))))
	(show' t 0 (SPosition 0 0))
)))

(def annotatePositions (\content
	(zip content (scanl
		(\l0c0 c (l0c0 (\l0 c0
			((= c '\n') (pair (+ 1 l0) 0)
				(pair l0 (+ 1 c0)))
		))) (SPosition 0 0) content)
	)
))
(def dropWhiteSpace (recur (\self (\l (run    ; SMayFail [(Char,SPosition)]
	(aap ar (l (SSucc empty)))
	(a ap aap)
	( ((isSpace a) (self ar)))
	( ((= a ';') (self (dropWhile (. (/= '\n') fst) ar))))
	(let waitUntilClose (recur (\f (\ar ap (run
		(har arr (ar (SFail "unclosed block comment" ap)))
		(harr arrr (arr (SFail "unclosed block comment" ap)))
		( ((and (= (fst har) '|') (= (fst harr) '#')) (self arrr)))
		(f arr ap)
	)))))
	( (\c ((/= a '#') c (ar c (\har arr ((= (fst har) '|') (waitUntilClose arr ap) c))))))
	(SSucc l)
)))))

(let isValidCharInt (\a (and (>= a 0) (< a 256))))

;splitChrSpecial :: [(Char,SPosition)] -> SPosition -> SMayFail (Char,[(Char,SPosition)])
(def splitChrSpecial (\ar ap (run
	(har arr (ar (SFail "incomplete escape sequence" ap)))
	( ((= (fst har) 'a') (SSucc (pair '\a' arr))))
	( ((= (fst har) 'b') (SSucc (pair '\b' arr))))
	( ((= (fst har) 'n') (SSucc (pair '\n' arr))))
	( ((= (fst har) 'r') (SSucc (pair '\r' arr))))
	( ((= (fst har) 'v') (SSucc (pair '\v' arr))))
	( ((= (fst har) 'f') (SSucc (pair '\f' arr))))
	( ((= (fst har) 't') (SSucc (pair '\t' arr))))
	( ((= (fst har) '\\') (SSucc (pair '\\' arr))))
	( ((= (fst har) '\'') (SSucc (pair '\'' arr))))
	( ((= (fst har) '\"') (SSucc (pair '\"' arr))))
	( ((= (fst har) 'x') (run
		(npart arrr (span (. isDigit fst) arr))
		(_ _ (npart (SFail "\\x must be followed by digits" ap)))
		(let c_int (intFromDigits (map fst npart)))
		( (isValidCharInt c_int (SSucc (pair c_int arrr))))
		(SFail "\\x value not in range" ap)
	)))
	(SSucc (pair (fst har) arr))
)))
; splitStrLiteral :: [(Char,SPosition)] -> SPosition -> SMayFail ((SToken,SPosition),[(Char,SPosition)])
(def splitStrLiteral (\ar ap (run
	; splitStrLiteralS :: [(Char,SPosition)] -> SMayFail ([Char],[(Char,SPosition)])
	(let splitStrLiteralS (recur (\self (\ar ap (run
		(har arr (ar (SFail "unmatched \"" ap)))
		( ((= (fst har) '"') (SSucc (pair "" arr))))
		( ((= (fst har) '\\') (run
			(c arrr (,<-SMF (splitChrSpecial arr (snd har))))
			(sr arrrr (,<-SMF (self arrr ap)))
			(SSucc (pair (cons c sr) arrrr))
		)))
		(sr arrr (,<-SMF (self arr ap)))
		(SSucc (pair (cons (fst har) sr) arrr))
	)))))
	(ps (<-SMF (splitStrLiteralS ar ap)))
	(s r ps)
	(SSucc (pair (pair (STStr s) ap) r))
)))
; splitCharLiteral :: [(Char,SPosition)] -> SPosition -> SMayFail ((SToken,SPosition),[(Char,SPosition)])
(def splitCharLiteral (recur (\self (\ar ap (run
	(har arr (ar (SFail "unmatched \'" ap)))
	( ((= (fst har) '\'') (SFail "empty ''" ap)))
	(let on_error (SFail "unmatched \'" ap))
	( ((= (fst har) '\\') (run
		(c arrr (,<-SMF (splitChrSpecial arr ap)))
		(harrr arrrr (arrr on_error))
		( ((= (fst harrr) '\'') (SSucc (pair (pair (STInt c) ap) arrrr))))
		on_error
	)))
	(harr arrr (arr on_error))
	( ((= (fst harr) '\'') (SSucc (pair (pair (STInt (fst har)) ap) arrr))))
	on_error
)))))
(def isStopChar (\c (or (isSpace c) (any (= c) "()\\;"))))

; splitNumLiteral :: [(Char,SPosition)] -> SMayFail ((SToken,SPosition),[(Char,SPosition)]) 
(def splitNumLiteral (\a (run
	(let ap (a (SPosition 0 0) (\h _ (snd h))))
	(sign a1 (run
		(ha ar (a (pair 1 a)))
		( ((= (fst ha) '+') (pair 1 ar)))
		( ((= (fst ha) '-') (pair -1 ar)))
		(pair 1 a)
	))
	(before_dot after_dot1 (span (. isDigit fst) a1))
	(let intret (SSucc (pair (pair (STInt (* sign (intFromDigits (map fst before_dot)))) ap) after_dot1)))
	( (\c (after_dot1 intret (\h r ((isStopChar (fst h)) intret c)))))
	(let after_dot (after_dot1 after_dot1 (\h r ((= (fst h) '.') r after_dot1))))
	(before_e after_e1 (span (. isDigit fst) after_dot))
	(has_e after_e (run
		(let other (pair False after_e1))
		(h r (after_e1 other))
		( ((= (fst h) 'e') (pair True r)))
		( ((= (fst h) 'E') (pair True r)))
		other
	))
	(neg_e after_es (run
		(let other (pair False after_e))
		( ((not has_e) other))
		(h r (after_e other))
		( ((= (fst h) '+') (pair False r)))
		( ((= (fst h) '-') (pair True r)))
		other
	))
	(before_end remain (span (. isDigit fst) after_es))
	( ((and has_e (null before_end)) (SFail "invalid float literal " ap)))
	(let int_part (intFromDigits (map fst before_dot)))
	(let mentisa_part (sum (zipWith * (map (. intFromDigit fst) before_e) (iterate (* 0.1) 0.1))))
	(let expint (before_end 0 (\_ _ (intFromDigits (map fst before_end)))))
	(let expbase (neg_e 0.1 10))
	(let e_part (iterateN expint (* expbase) 1))
	(SSucc (pair (pair (STDouble (* sign (* e_part (+ int_part mentisa_part)))) ap) remain))
)))

; splitFirstString :: [(Char,SPosition)] -> SMayFail ((SToken,SPosition),[(Char,SPosition)])
(def splitFirstString (\la (run
	(aap ar (la 0))
	(a ap aap)
	( ((= a '(') (SSucc (pair (pair STLeftPar ap) ar))))
	( ((= a ')') (SSucc (pair (pair STRightPar ap) ar))))
	( ((= a '\\') (SSucc (pair (pair STLambda ap) ar))))
	( ((= a '"') (splitStrLiteral ar ap)))
	( ((= a '\'') (splitCharLiteral ar ap)))
	( (((isDigit a) True ((any (= a) "+-.") (ar False (\h r (isDigit (fst h)))) False)) (splitNumLiteral la)))
	( ((isDigit a) (SFail "invalid number literal" ap)))
	(al arr (span (. not (. isStopChar fst)) la))
	(SSucc (pair (pair (STAtom (map fst al)) ap) arr))
)))

; groupStrings :: [(Char,SPosition)] -> SMayFail [(SToken,SPosition)] 
(def groupStrings (recur (\self (\x (run
	(dropped (<-SMF (dropWhiteSpace x)))
	(let groupStrings' (\a (run
		(_ _ (a (SSucc empty)))
		(f r (,<-SMF (splitFirstString a)))
		(remain (<-SMF (self r)))
		(SSucc (cons f remain))
	)))
	(groupStrings' dropped)
)))))

;firstTokenTree :: [(SToken,SPosition)] -> SMayFail ((STokenTree,SPosition),[(SToken,SPosition)])
(def firstTokenTree (recur (\self (\a (run
	(ha ar (a 0))
	(tha pha ha)
	(let groupUntilRightPar (recur (\self2 (\a sp (run
		(ha ar (a (SFail "unmatched (" #|)|# sp)))
		(tha pha ha)
		( (caseSTRightPar tha (SSucc (pair empty ar))))
		(t rr (,<-SMF (self a)))
		(ts rrr (,<-SMF (self2 rr sp)))
		(SSucc (pair (cons t ts) rrr))
	)))))
	( (caseSTLeftPar tha (run
		(trees remain (,<-SMF (groupUntilRightPar ar pha)))
		( ((null trees) (SFail "empty ()" pha)))
		(SSucc (pair (pair (STTList trees) pha) remain))
	)))
	( (caseSTRightPar tha (SFail #|(|# "unmatched )" pha)))
	(SSucc (pair (pair (STTNode tha) pha) ar))
)))))

;groupTokenTree :: [(SToken,SPosition)] -> SMayFail [(STokenTree,SPosition)]
(def groupTokenTree (recur (\self (\a (run
	(_ _ (a (SSucc empty)))
	(tt remain (,<-SMF (firstTokenTree a)))
	(rt (<-SMF (self remain)))
	(SSucc (cons tt rt))
)))))

(run
	;(let inp " ;haha\n #|lala|# #| papa|# ; pia\n(def a 1)\n(+ a 2)")
	(fin (open "aplusb.u" ReadMode))
	(inp (readContentF fin))
	(_ (close fin))
	;(let inp "' '")
	;(let inp "")
	;(let inp " a\\nbc\" a")
	;(let inp "(a' bc)")
	;(let inp "")
	(let annotated (annotatePositions inp))
	;(_ (putStrLn (showListPositionedChar annotated "")))
	(let onSError (\msg pos (run
		(_ (putStr (++ "parser error: " (++ msg " at "))))
		(_ (putStrLn (showSPosition pos "")))
		(exit 1)
	)))
	; (chopped (dropWhiteSpace annotated onSError))
	; (_ (putStrLn (showListPositionedChar chopped "")))
	; (_ (putStrLn (map fst chopped)))
	;(splitted (splitChrSpecial annotated (SPosition 0 0) onSError))
	;(c r splitted)
	;(_ (putStrLn (itoa c)))
	;(pst r (. (splitStrLiteral annotated (SPosition 0 0) onSError) feed))
	;(pst r (. (splitCharLiteral annotated (SPosition 0 0) onSError) feed))
	;(pst r (. (splitNumLiteral annotated onSError) feed))
	;(pst r (. (splitFirstString annotated onSError) feed))
	;(_ (putStrLn (showSToken (fst pst) "")))
	;(_ (putStrLn (showSPosition (snd pst) "")))
	;(_ (putStrLn (showListPositionedChar r "")))
	(sts (groupStrings annotated onSError))
	(_ (putStrLn (showListPositionedSTToken sts "")))
	;(_ (putStr (showSTokenTree 
		;(STTList (list 
			;(pair (STTNode (STAtom "ha")) (SPosition 0 1))
			;(pair (STTNode (STAtom "pia")) (SPosition 0 2))
		;))
		;"")))
	;(pt r (. (firstTokenTree sts onSError) feed))
	;(t p pt)
	;(_ (putStr (showSTokenTree t "")))
	;(_ (putStrLn (showSPosition p "")))
	(stts (groupTokenTree sts onSError))
	(_ (putStrLn (showList (showPair showSTokenTree showSPosition) stts "")))
	(exit 0)
)
