; for historical pleasure
(def S (\x y a ((x a) (y a))))
(def K (\x y x))

(def id (\x x))
(def recur (\f ((\x (f (x x))) (\x (f (x x))))))
(def print id)
(def die (recur id))  ; this makes the program runs forever
(def const K)

; the Bool protocol:   (b  true_value  false_value)
(def True (\x y x))
(def False (\x y y))
(def if id)
(def not (\x (x False True)))
(def and (\x y (x y False)))
(def or (\x y (x True y)))

; the Pair protocol:   (p (\first second pair_value))
(def pair (\x y f (f x y)))
(def fst True)
(def snd False)

; the List protocol:   (l null_value (\head tail list_value))
(def cons (\x xs f g (g x xs)))
(def empty fst)
(def null (\x (x True (\_ _ False))))
(def foldr (\f x0 (recur (\g (\l
	(l x0 (\x xs
		(f x (g xs))
	)))))
))
(def foldl (\f (recur (\g (\x0 l
	(l x0 (\x xs
		(g (f x0 x) xs))
	))))
))
(def foldr1 (\f f1 x0 (recur (\g l
	(l x0 (\x xs
		(xs (f1 x) (\_ _
			(f x (g xs))
		))
	))))
))
(def ++ (\a b (foldr (\x y (cons x y)) b a)))
(def join (\sep (foldr1 (\x y (++ x (++ sep y))) id empty)))
(def sum (foldl + 0))
(def map (\f (foldr (\h r (cons (f h) r)) empty)))

; the Maybe protocol:  (m nothing_value (\v just_value))
(def nothing fst)
(def just (\v (\f g (g v))))

; functional utils
(def apply id)
(def feed (\x y (y x)))

; numeric utils
(def neg (- 0))

; converting strings to built-in strings
(let fileName (recur (\f (\name
	(name
		makeIntList
		(\h r ((f r) h))
	)
))))
(def open (\f (openCmd (fileName f))))
(def system (\f (systemCmd (fileName f))))
