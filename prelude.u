; for historical pleasure
(def S (\x y a ((x a) (y a))))
(def K (\x y x))

; functional tools
(def id (\x x))
(def recur (\f ((\x (f (x x))) (\x (f (x x))))))
(def print id)
(def die (recur id))  ; this makes the program runs forever
(def const K)
(def . (\f g x (f (g x))))
(def apply id)
(def feed (\x y (y x)))
(def flip (\f y x (f x y)))
(def iterateN (recur (\g i f x
	((<= i 0) x
		(f (g (- i 1) f x))
	)
)))

; the Bool protocol:   (b  true_value  false_value)
(def True (\x y x))
(def False (\x y y))
(def if id)
(def not (\x (x False True)))
(def and (\x y (x y False)))
(def or (\x y (x True y)))

; the Pair protocol:   (p (\first second pair_value))
(def pair (\x y f (f x y)))
(def fst (feed True))
(def snd (feed False))

; the List protocol:   (l null_value (\head tail list_value))
(def cons (\x xs f g (g x xs)))
(def empty True)
(def null (\x (x True (\_ _ False))))
(def foldr (\f x0 (recur (\g (\l
	(l x0 (\x xs
		(f x (g xs))
	)))))
))
(def foldl (\f (recur (\g (\x0 l
	(l x0 (\x xs
		(g (f x0 x) xs))
	))))
))
(def foldr1 (\f f1 x0 (recur (\g l
	(l x0 (\x xs
		(xs (f1 x) (\_ _
			(f x (g xs))
		))
	))))
))
(def ++ (\a b (foldr (\x y (cons x y)) b a)))
(def join (\sep (foldr1 (\x y (++ x (++ sep y))) id empty)))
(def concat (foldr ++ empty))
(def sum (foldl + 0))
(def map (\f (foldr (\h r (cons (f h) r)) empty)))
(def cmpList (\cmp (recur (\f (\l1 l2
	(l1 (l2 False (\_ _ True)) (\h1 r1 (l2 False (\h2 r2
		((cmp h1 h2) True
			((cmp h2 h1) False
				(f r1 r2)
			)
		)
	))))
)))))
(def dropWhile (\cond (recur (\f (\l
	(l l (\h r
		((cond h) (f r) l)
	))
)))))
(def takeWhile (\cond (recur (\f (\l
	(l l (\h r
		((cond h) (cons h (f r)) empty)
	))
)))))
(def span (\cond (recur (\f (\l
	(l (pair l l) (\h r
		((cond h) ((f r) (\l1 l2 (pair (cons h l1) l2)))
			(pair empty l)
		)
	))
)))))
(def zipWith (\f (recur (\g a b
	(a empty (\ha ra
		(b empty (\hb rb
			(cons (f ha hb) (g ra rb))
		))
	))
))))

; the Maybe protocol:  (m nothing_value (\v just_value))
(def nothing True)
(def just (\v (\f g (g v))))


; numeric utils
(def neg (- 0))

; IO macros
(let fileName (recur (\f (\name
	(name
		makeIntList
		(\h r ((f r) h))
	)
))))
(def open (\f (openCmd (fileName f))))
(def system (\f (systemCmd (fileName f))))
(def ReadMode 0)
(def WriteMode 1)
(def AppendMode 2)
(def ReadWriteMode 3)
(def stdin 0)
(def stdout 1)

; run macros
(def ^list (\l f (foldl apply f l)))

(def head1 (\e l f (l e (\h1 r1 (f h1 r1)))))
(def head2 (\e l f (l e (\h1 r1 (r1 e (\h2 r2 (f h1 h2 r2)))))))
(def head3 (\e l f (l e (\h1 r1 (r1 e (\h2 r2 (r2 e (\h3 r3 (f h1 h2 h3 r3)))))))))
